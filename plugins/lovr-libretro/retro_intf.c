#include "log.h"
#include "retro_intf.h"

#include <assert.h>
#include <dlfcn.h>
#include <errno.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "libretro.h"

// Interface with the libretro core.
static struct {
    void *handle;
    bool initialized;

    void (*retro_init)(void);
    void (*retro_deinit)(void);
    unsigned (*retro_api_version)(void);
    void (*retro_get_system_info)(struct retro_system_info *info);
    void (*retro_get_system_av_info)(struct retro_system_av_info *info);
    void (*retro_set_controller_port_device)(unsigned port, unsigned device);
    void (*retro_reset)(void);
    void (*retro_run)(void);
    //size_t (*retro_serialize_size)(void);
    //bool (*retro_serialize)(void *data, size_t size);
    //bool (*retro_unserialize)(const void *data, size_t size);
    //void retro_cheat_reset(void);
    //void retro_cheat_set(unsigned index, bool enabled, const char *code);
    bool (*retro_load_game)(const struct retro_game_info *game);
    //bool retro_load_game_special(unsigned game_type, const struct retro_game_info *info, size_t num_info);
    void (*retro_unload_game)(void);
    //unsigned retro_get_region(void);
    //void *retro_get_memory_data(unsigned id);
    //size_t retro_get_memory_size(unsigned id);

    void (*retro_set_environment)(retro_environment_t);
    void (*retro_set_video_refresh)(retro_video_refresh_t);
    void (*retro_set_input_poll)(retro_input_poll_t);
    void (*retro_set_input_state)(retro_input_state_t);
    void (*retro_set_audio_sample)(retro_audio_sample_t);
    void (*retro_set_audio_sample_batch)(retro_audio_sample_batch_t);
} gRetroCore;

// Parameters related to the video frame generation.
static struct {
    // Destination buffer registered by the client.
    void* dstBuf;
    // Details of the video frames generated by the core.
    size_t frameWidth;
    size_t frameHeight;
    // Pixel format used by the core.
    int framePixelFormat;
} gVideo;

static void
_retro_cb_audio_sample(int16_t left, int16_t right)
{
    //TODO.
}

static void
_retro_cb_log(enum retro_log_level level, char const* fmt, ...)
{
    char buffer[4096] = {0};
    static const char * levelstr[] = { "dbg", "inf", "wrn", "err" };
    va_list va;

    va_start(va, fmt);
    vsnprintf(buffer, sizeof(buffer), fmt, va);
    va_end(va);

    LOG("[%s] %s", levelstr[level], buffer);

    if (level == RETRO_LOG_ERROR)
        exit(EXIT_FAILURE);
}

static size_t
_retro_cb_audio_sample_batch(int16_t const* data, size_t frame)
{
    //TODO.
    return frame;
}

static bool
_retro_cb_environment(unsigned cmd, void* data)
{
    switch (cmd) {
    case RETRO_ENVIRONMENT_GET_LOG_INTERFACE:
        ((struct retro_log_callback *) data)->log = _retro_cb_log;
        break;
   case RETRO_ENVIRONMENT_GET_CAN_DUPE:
        *((bool*)data) = true;
        break;
    case RETRO_ENVIRONMENT_SET_PIXEL_FORMAT:
        gVideo.framePixelFormat = *((enum retro_pixel_format *) data);
        LOG("%s: changing pixel format to fmt=%d\n", __func__,
            gVideo.framePixelFormat);
        break;
    case RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY:
        *(const char **)data = ".";
        break;
    case RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY:
        *(const char **)data = ".";
        break;
    default:
        return false;
    }

    return true;
}

static void
_retro_cb_input_poll(void)
{
    //TODO.
}

static int16_t
_retro_cb_input_state(unsigned port, unsigned device, unsigned index,
    unsigned id)
{
    //TODO.
    return 0;
}

static void
_retro_cb_video_refresh(void const* data, unsigned width, unsigned height,
    size_t pitch)
{
    if (!gVideo.dstBuf) {
        return;
    }

    /*
     * TODO: as of right now, clients specify an RGBA8888 buffer and we
     * copy/convert the newly produced frame into the client's provided
     * destination buffer. Instead, I am wondering if we can avoid these
     * copies by either mmap'ing an OpenGL texture, or by providing the
     * buffer to the core directly.
     */
    if (gVideo.framePixelFormat == RETRO_PIXEL_FORMAT_RGB565) {
        uint16_t const* src = (uint16_t const*) data;
        uint8_t* dst = gVideo.dstBuf;

        for (size_t i = 0; i < gVideo.frameWidth * gVideo.frameHeight; ++i) {
            dst[4 * i + 0] = (255.f / 31.f) * ((src[i] & 0xf800) >> 11);
            dst[4 * i + 1] = (255.f / 63.f) * ((src[i] & 0x07e0) >> 5);
            dst[4 * i + 2] = (255.f / 31.f) * ((src[i] & 0x001f));
            dst[4 * i + 3] = 255;
        }
    } else {
        // TODO: support other format.
    }
}

static bool
_retro_intf_core_load_core_from_file(char const* corePath)
{
    bool success = false;

    assert(corePath);
    assert(!gRetroCore.handle);

    gRetroCore.handle = dlopen(corePath, RTLD_LAZY);
    if (!gRetroCore.handle) {
        LOG("%s: dlopen() failed, reason: %s\n", __func__, dlerror());
        goto out;
    }

#define _core_load_sym(S) do {                                          \
    *(void **) &gRetroCore.S = dlsym(gRetroCore.handle, #S);            \
    if (gRetroCore.S == NULL) {                                         \
        LOG("%s: dlsym() failed, reason: %s\n", __func__, dlerror());   \
        goto out;                                                       \
    }                                                                   \
} while (0)
    _core_load_sym(retro_init);
    _core_load_sym(retro_deinit);
    _core_load_sym(retro_api_version);
    _core_load_sym(retro_get_system_info);
    _core_load_sym(retro_get_system_av_info);
    _core_load_sym(retro_set_controller_port_device);
    _core_load_sym(retro_reset);
    _core_load_sym(retro_run);
    _core_load_sym(retro_load_game);
    _core_load_sym(retro_unload_game);
    _core_load_sym(retro_set_environment);
    _core_load_sym(retro_set_video_refresh);
    _core_load_sym(retro_set_input_poll);
    _core_load_sym(retro_set_input_state);
    _core_load_sym(retro_set_audio_sample);
    _core_load_sym(retro_set_audio_sample_batch);
#undef _core_load_sym

    gRetroCore.retro_set_environment(_retro_cb_environment);
    gRetroCore.retro_set_video_refresh(_retro_cb_video_refresh);
    gRetroCore.retro_set_input_poll(_retro_cb_input_poll);
    gRetroCore.retro_set_input_state(_retro_cb_input_state);
    gRetroCore.retro_set_audio_sample(_retro_cb_audio_sample);
    gRetroCore.retro_set_audio_sample_batch(_retro_cb_audio_sample_batch);

    gRetroCore.retro_init();
    gRetroCore.initialized = true;

    success = true;
out:
    return success;
}

static bool
_retro_intf_core_load_game_from_file(char const* gamePath)
{
    bool success = false;

    assert(gamePath);
    assert(gRetroCore.handle);
    assert(gRetroCore.retro_load_game);

    FILE* file = fopen(gamePath, "rb");
    if (!file) {
        LOG("%s: fopen() failed, reason: %s\n", __func__, strerror(errno));
        goto out;
    }

    struct retro_game_info gameInfo = { gamePath, 0 };
    fseek(file, 0, SEEK_END);
    gameInfo.size = ftell(file);
    fseek(file, 0, SEEK_SET);

    struct retro_system_info systemInfo = {0};
    gRetroCore.retro_get_system_info(&systemInfo);

    if (!systemInfo.need_fullpath) {
        gameInfo.data = malloc(gameInfo.size);
        if (!gameInfo.data) {
            LOG("%s: couldn't allocate game's memory\n", __func__);
            goto out;
        }

        if (!fread((void*) gameInfo.data, gameInfo.size, 1, file)) {
            LOG("%s: fread() failed, reason: %s\n", __func__, strerror(errno));
            goto out;
        }
    }

    if (!gRetroCore.retro_load_game(&gameInfo)) {
        LOG("%s: libretro failed to load game '%s'\n",
            __func__, gamePath);
        goto out;
    }

    success = true;

out:
    if (!success)
        free((void*) gameInfo.data);
    fclose(file);

    return true;
}

retro_intf_ret_t
retro_intf_init(char const* corePath, char const* gamePath)
{
    retro_intf_ret_t ret = kRetroIntfRetNoError;

    assert(corePath);
    assert(gamePath);
    assert(!gRetroCore.handle);
    assert(!gRetroCore.initialized);

    // Firstly, load the core from its .so.
    if (!_retro_intf_core_load_core_from_file(corePath)) {
        LOG("%s: could not load core '%s'\n", __func__, corePath);
        ret = kRetroIntfRetCoreNotFound;
        goto out;
    }

    // Secondly, load the game (aka ROM).
    if (!_retro_intf_core_load_game_from_file(gamePath)) {
        LOG("%s: could not load game '%s'\n", __func__, gamePath);
        ret = kRetroIntfRetGameNotFound;
        goto out;
    }

    gRetroCore.initialized = true;
    LOG("%s: core initialized, core:%s game:%s\n",
        __func__, corePath, gamePath);

    // Determine the video frame dimension.
    struct retro_system_av_info avInfo;
    gRetroCore.retro_get_system_av_info(&avInfo);
    gVideo.frameWidth = avInfo.geometry.base_width;
    gVideo.frameHeight = avInfo.geometry.base_height;
    LOG("%s: av.w=%d av.h=%d\n", __func__,
        avInfo.geometry.max_width, avInfo.geometry.max_height);

out:
    if (ret != kRetroIntfRetNoError)
        retro_intf_deinit();
    return ret;
}

void
retro_intf_deinit(void)
{
    if (gRetroCore.initialized) {
        gRetroCore.retro_deinit();
    }

    if (gRetroCore.handle) {
        int ret = dlclose(gRetroCore.handle);
        if (ret != 0) {
            LOG("%s: dlclose() failed, reason: %s\n",
                __func__, dlerror());
        }
    }

    (void)memset(&gRetroCore, 0, sizeof(gRetroCore));
}

void
retro_intf_run(void)
{
    if (gRetroCore.initialized) {
        gRetroCore.retro_run();
    }
}

void
retro_intf_set_video_buffer(void* buf)
{
    gVideo.dstBuf = buf;
    LOG("%s: changed video buffer destination, dst=%p\n", __func__, buf);
}

